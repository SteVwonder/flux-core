#!/usr/bin/env python

from __future__ import print_function

import re
import sys
import argparse
import json
from collections import Sequence

import yaml


def create_resource(res_type, count, with_child=[]):
    assert isinstance(with_child, Sequence), "child resource must be a sequence"
    assert not isinstance(with_child, str), "child resource must not be a string"
    assert count > 0, "resource count must be > 0"

    res = {"type": res_type, "count": count}

    if len(with_child) > 0:
        res["with"] = with_child
    return res


def create_slot(label, count, with_child):
    slot = create_resource("slot", count, with_child)
    slot["label"] = label
    return slot


def create_slurm_style_jobspec(
    command, num_tasks, cores_per_task, num_nodes=0, walltime=None, distribution=None
):
    core = create_resource("core", cores_per_task)
    slot = create_slot("task", 1, [core])
    if num_nodes > 0:
        resource_section = create_resource("node", num_nodes, [slot])
    else:
        resource_section = slot

    jobspec = {
        "version": 1,
        "resources": [resource_section],
        "tasks": [
            {
                "command": command,
                "slot": "task",
                "count": {"total": num_tasks},
                "attributes": {},
            }
        ],
        "attributes": {"system": {}},
    }
    if walltime:
        jobspec["attributes"]["system"]["duration"] = walltime

    if distribution:
        distributions = distribution.lower().split(":")
        try:
            distributions[-1], pack = distributions[-1].split(',')
        except ValueError:
            pack = None
        distribution_labels = ["nodes", "sockets", "cores"]
        distribution_dict = {
            key: value for (key, value) in zip(distribution_labels, distributions)
        }
        if pack:
            distribution_dict['pack'] = False if pack == 'nopack' else True
        jobspec["tasks"][0]["attributes"]["distribution"] = distribution_dict

    return jobspec


def validate_slurm_args(args):
    # distribution argument
    if args.distribution:
        choices = ["block", "cyclic"]
        distributions = args.distribution.lower().split(":")
        try:
            distributions[-1], pack = distributions[-1].split(',')
        except ValueError:
            pack = None

        if len(distributions) > 3:
            raise ValueError(
                "too many distributions provided; at most 3 can be provided"
            )
        for distribution in distributions:
            if distribution not in choices:
                raise ValueError(
                    "distribution option provided must be one of {}, not '{}'".format(choices, distribution)
                )
        if pack and pack not in ['pack', 'nopack']:
            raise ValueError("Pack option must be either Pack or NoPack, not '{}'".format(pack))

    if (
        args.time
        and re.match(r"^(\d+-)?\d+:\d+:\d+$") is None
        and re.match(r"^\d+(:\d+)?$") is None
    ):
        raise ValueError(
            "invalid time limit string format. "
            "Acceptable formats include minutes[:seconds], [days-]hours:minutes:seconds"
        )

    # TODO: is there any validation of the stdout redirection path that we can do?
    # IDEA: print a warning if the file already exists or if the parent dir doesn't exist


def slurm_jobspec(args):
    try:
        validate_slurm_args(args)
    except ValueError as e:
        print("Input Error: {}".format(e.message), file=sys.stderr)
        sys.exit(1)
    return create_slurm_style_jobspec(
        args.command,
        args.ntasks,
        args.cpus_per_task,
        args.nodes,
        args.time,
        args.distribution,
    )


DISTRIBUTION_RE = r"(block|cyclic)(:(block|cyclic)){0,2}(,(Pack|NoPack))?"
def get_slurm_common_parser():
    """
    Shared arguments amongst srun and sbatch.
    Used src/srun/libsrun/opt.c and src/sbatch/opt.c of the
    [SLURM repository](https://github.com/SchedMD/slurm.git) as reference
    """
    slurm_parser = argparse.ArgumentParser(add_help=False)
    slurm_parser.add_argument("-N", "--nodes", type=int, default=0)
    slurm_parser.add_argument("-n", "--ntasks", type=int, default=1)
    slurm_parser.add_argument("-c", "--cpus-per-task", type=int, default=1)
    slurm_parser.add_argument(
        "-m",
        "--distribution",
        type=str,
        help="specify alternate distribution methods for remote processes. "
        "Acceptable formats regex: "
        + DISTRIBUTION_RE
    )
    slurm_parser.add_argument(
        "-t",
        "--time",
        help="time limit. Acceptable formats include minutes[:seconds], "
        "[days-]hours:minutes:seconds",
    )
    slurm_parser.add_argument("-o", "--output", help="location of stdout redirection")
    slurm_parser.add_argument("command", nargs=argparse.REMAINDER)
    return slurm_parser


def main():
    parser = argparse.ArgumentParser()


    output_format_group = parser.add_mutually_exclusive_group()
    output_format_group.add_argument(
        "--yaml", action="store_true", help="output the jobspec as yaml"
    )
    output_format_group.add_argument(
        "--json",
        action="store_true",
        help="output the jobspec as json (default)",
        default=True,
    )

    subparsers = parser.add_subparsers()
    slurm_parser = get_slurm_common_parser()
    srun_parser = subparsers.add_parser("srun", parents=[slurm_parser], help="subcommand for SLURM-style CLI arguments")
    srun_parser.set_defaults(func=slurm_jobspec)

    args = parser.parse_args()

    if len(args.command) == 0:
        parser.error("command is required")
        sys.exit(1)

    jobspec = args.func(args)

    if args.yaml:
        out = yaml.dump(jobspec)
    else:
        out = json.dumps(jobspec)
    print(out)


if __name__ == "__main__":
    try:
        main()
    except SystemExit as e: # don't intercept sys.exit calls
        sys.exit(e)
    except Exception as e:
        print("Unknown error: {}".format(e.message), file=sys.stderr)
        sys.exit(1)
    sys.exit(0)
